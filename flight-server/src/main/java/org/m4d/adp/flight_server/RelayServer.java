/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.m4d.adp.flight_server;

import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.*;
import com.fasterxml.jackson.core.type.TypeReference;
import com.google.common.base.Charsets;
import com.google.common.io.CharStreams;

import org.apache.arrow.flight.*;
import org.apache.arrow.memory.BufferAllocator;
import org.apache.arrow.memory.RootAllocator;
import org.apache.arrow.util.AutoCloseables;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Options;
import org.apache.commons.compress.utils.IOUtils;
import org.yaml.snakeyaml.Yaml;


public class RelayServer implements AutoCloseable {

    private final FlightServer flightServer;
    private final BufferAllocator allocator;

    public void close() throws Exception {
        AutoCloseables.close(flightServer, allocator);
    }

    public RelayServer(BufferAllocator incomingAllocator, Location location, NoOpFlightProducer producer) {
        this.allocator = incomingAllocator.newChildAllocator("flight-server", 0, Long.MAX_VALUE);
        this.flightServer = FlightServer.builder(this.allocator, location, producer).build();
    }

    public void start() throws IOException {
        flightServer.start();
    }

    public void awaitTermination() throws InterruptedException {
        flightServer.awaitTermination();
    }

    public static void main(String[] args) throws Exception {
        System.out.println("relay server");
        // boolean relay = true;
        boolean transform = true;
        String host;
        int port;
        String remote_host = null;
        int remote_port = 0;
        BufferAllocator a;
        CommandLineParser parser = new DefaultParser();
        Options options = new Options();

        options.addOption("h", "host", true, "Host");
        options.addOption("p", "port", true, "Port");
        options.addOption("rh", "remote_host", true, "Remote host");
        options.addOption("rp", "remote_port", true, "Remote port");

        CommandLine line = parser.parse( options, args );
        String allocator_type = line.getOptionValue("alloc", "Root");
        a = new RootAllocator(Long.MAX_VALUE);
        remote_host = line.getOptionValue("remote_host", "localhost");
        remote_port = Integer.valueOf(line.getOptionValue("remote_port", "12233"));
        
        host = line.getOptionValue("host", "0.0.0.0");
        port = Integer.valueOf(line.getOptionValue("port", "12232"));

        ////yaml////
        InputStream inputStream = new FileInputStream(new File("/etc/conf/conf.yaml"));
        
        String yamlStr = CharStreams.toString(new InputStreamReader(inputStream, Charsets.UTF_8));

        ObjectMapper yamlReader = new ObjectMapper(new YAMLFactory());

        Object obj = yamlReader.readValue(yamlStr, Object.class);
        ObjectMapper jsonWriter = new ObjectMapper();
        String jsonStr =  jsonWriter.writeValueAsString(obj);

        
        // ObjectMapper mapper = new ObjectMapper();
        // Map<String, Object> conf = mapper.readValue(jsonStr, new TypeReference<Map<String, Object>>(){});
        // // System.out.println(conf);

        // // Yaml yaml = new Yaml();
        // // Map<String, Object> conf = yaml.load(inputStream);
        // List<Map<String, Object>> data = (List<Map<String, Object>>) conf.get("data");
        // System.out.println("len data = " + data.size());
        // Map<String, Object> data1 = data.get(0);
        // boolean withTransformation = data1.containsKey("transformations");
        // // Object transformationsObject = conf.get("transformations");
        // System.out.println(conf);
        // System.out.println(withTransformation);
        // for (int i = 0; i < data.size(); i++) {
        //     Map<String, Object> dataset = data.get(i);

        //     List<Map<String, Object>> transformations = (List<Map<String, Object>>) dataset.get("transformations");
        //     String ociImage = (String) transformations.get(0).get("image");
        //     System.out.println("assetId: " + dataset.get("name") + " transformations: " + transformations + " oci image: " + ociImage);
        // }
        // transform = withTransformation;
        // if (withTransformation) {
        //     List<Map<String, Object>> transformations = (List<Map<String, Object>>) data1.get("transformations");
        //     String action = (String) transformations.get(0).get("action");
        //     System.out.println(action);
        // }



        ////yaml////

        final Location location;
        final NoOpFlightProducer producer;
        location = Location.forGrpcInsecure(host, port);
        Location remote_location = Location.forGrpcInsecure(remote_host, remote_port);
        producer = new RelayProducer(location, remote_location, a, transform, false, jsonStr);


        final RelayServer rs = new RelayServer(a, location, producer);
        rs.start();
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                System.out.println("\nExiting...");
                AutoCloseables.close(rs, a);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }));
        rs.awaitTermination();
    }
}
